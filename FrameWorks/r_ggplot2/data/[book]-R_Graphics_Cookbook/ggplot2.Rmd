---
title: "R Graphics Cookbook"
author: "zfwang"
date: "22 January 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	fig.align = "center",
	fig.height = 6,
	fig.width = 6
)
```

----

## Table of Contents

* Preface
1. R Basics
    - 1.1. Installing a Package 1
    - 1.2. Loading a Package 2
    - 1.3. Loading a Delimited Text Data File 3
    - 1.4. Loading Data from an Excel File 4
    - 1.5. Loading Data from an SPSS File 5
2. Quickly Exploring Data
    - 2.1. Creating a Scatter Plot 7
    - 2.2. Creating a Line Graph 9
    - 2.3. Creating a Bar Graph 11
    - 2.4. Creating a Histogram 13
    - 2.5. Creating a Box Plot 15
    - 2.6. Plotting a Function Curve 17
3. Bar Graphs
    - 3.1. Making a Basic Bar Graph 19
    - 3.2. Grouping Bars Together 22
    - 3.3. Making a Bar Graph of Counts 25
    - 3.4. Using Colors in a Bar Graph 27
    - 3.5. Coloring Negative and Positive Bars Differently 29
    - 3.6. Adjusting Bar Width and Spacing 30
    - 3.7. Making a Stacked Bar Graph 32
    - 3.8. Making a Proportional Stacked Bar Graph 35
    - 3.9. Adding Labels to a Bar Graph 38
    - 3.10. Making a Cleveland Dot Plot 42
4. Line Graphs
    - 4.1. Making a Basic Line Graph 49
    - 4.2. Adding Points to a Line Graph 52
    - 4.3. Making a Line Graph with Multiple Lines 53
    - 4.4. Changing the Appearance of Lines 58
    - 4.5. Changing the Appearance of Points 59
    - 4.6. Making a Graph with a Shaded Area 62
    - 4.7. Making a Stacked Area Graph 64
    - 4.8. Making a Proportional Stacked Area Graph 67
    - 4.9. Adding a Confidence Region 69
5. Scatter Plots
    - 5.1. Making a Basic Scatter Plot 73
    - 5.2. Grouping Data Points by a Variable Using Shape or Color 75
    - 5.3. Using Different Point Shapes 77
    - 5.4. Mapping a Continuous Variable to Color or Size 80
    - 5.5. Dealing with Overplotting 84
    - 5.6. Adding Fitted Regression Model Lines 89
    - 5.7. Adding Fitted Lines from an Existing Model 94
    - 5.8. Adding Fitted Lines from Multiple Existing Models 97
    - 5.9. Adding Annotations with Model Coefficients 100
    - 5.10. Adding Marginal Rugs to a Scatter Plot 103
    - 5.11. Labeling Points in a Scatter Plot 104
    - 5.12. Creating a Balloon Plot 110
    - 5.13. Making a Scatter Plot Matrix 112
6. Summarized Data Distributions
    - 6.1. Making a Basic Histogram 117
    - 6.2. Making Multiple Histograms from Grouped Data 120
    - 6.3. Making a Density Curve 123
    - 6.4. Making Multiple Density Curves from Grouped Data 126
    - 6.5. Making a Frequency Polygon 129
    - 6.6. Making a Basic Box Plot 130
    - 6.7. Adding Notches to a Box Plot 133
    - 6.8. Adding Means to a Box Plot 134
    - 6.9. Making a Violin Plot 135
    - 6.10. Making a Dot Plot 139
    - 6.11. Making Multiple Dot Plots for Grouped Data 141
    - 6.12. Making a Density Plot of Two-Dimensional Data 143
7. Annotations
    - 7.1. Adding Text Annotations 147
    - 7.2. Using Mathematical Expressions in Annotations 150
    - 7.3. Adding Lines 152
    - 7.4. Adding Line Segments and Arrows 155
    - 7.5. Adding a Shaded Rectangle 156
    - 7.6. Highlighting an Item 157
    - 7.7. Adding Error Bars 159
    - 7.8. Adding Annotations to Individual Facets 162
8. Axes
    - 8.1. Swapping X- and Y-Axes 167
    - 8.2. Setting the Range of a Continuous Axis 168
    - 8.3. Reversing a Continuous Axis 170
    - 8.4. Changing the Order of Items on a Categorical Axis 172
    - 8.5. Setting the Scaling Ratio of the X- and Y-Axes 174
    - 8.6. Setting the Positions of Tick Marks 177
    - 8.7. Removing Tick Marks and Labels 178
    - 8.8. Changing the Text of Tick Labels 180
    - 8.9. Changing the Appearance of Tick Labels 182
    - 8.10. Changing the Text of Axis Labels 184
    - 8.11. Removing Axis Labels 185
    - 8.12. Changing the Appearance of Axis Labels 187
    - 8.13. Showing Lines Along the Axes 189
    - 8.14. Using a Logarithmic Axis 190
    - 8.15. Adding Ticks for a Logarithmic Axis 196
    - 8.16. Making a Circular Graph 198
    - 8.17. Using Dates on an Axis 204
    - 8.18. Using Relative Times on an Axis 207
9. Controlling the Overall Appearance of Graphs
    - 9.1. Setting the Title of a Graph 211
    - 9.2. Changing the Appearance of Text 213
    - 9.3. Using Themes 216
    - 9.4. Changing the Appearance of Theme Elements 218
    - 9.5. Creating Your Own Themes 221
    - 9.6. Hiding Grid Lines 222
10. Legends
    - 10.1. Removing the Legend 225
    - 10.2. Changing the Position of a Legend 227
    - 10.3. Changing the Order of Items in a Legend 229
    - 10.4. Reversing the Order of Items in a Legend 231
    - 10.5. Changing a Legend Title 232
    - 10.6. Changing the Appearance of a Legend Title 235
    - 10.7. Removing a Legend Title 236
    - 10.8. Changing the Labels in a Legend 237
    - 10.9. Changing the Appearance of Legend Labels 239
    - 10.10. Using Labels with Multiple Lines of Text 240
11. Facets
    - 11.1. Splitting Data into Subplots with Facets 243
    - 11.2. Using Facets with Different Axes 246
    - 11.3. Changing the Text of Facet Labels 246
    - 11.4. Changing the Appearance of Facet Labels and Headers 250
12. Using Colors in Plots
    - 12.1. Setting the Colors of Objects 251
    - 12.2. Mapping Variables to Colors 252
    - 12.3. Using a Different Palette for a Discrete Variable 254
    - 12.4. Using a Manually Defined Palette for a Discrete Variable 259
    - 12.5. Using a Colorblind-Friendly Palette 261
    - 12.6. Using a Manually Defined Palette for a Continuous Variable 263
    - 12.7. Coloring a Shaded Region Based on Value 264
13. Miscellaneous Graphs
    - 13.1. Making a Correlation Matrix 267
    - 13.2. Plotting a Function 271
    - 13.3. Shading a Subregion Under a Function Curve 272
    - 13.4. Creating a Network Graph 274
    - 13.5. Using Text Labels in a Network Graph 278
    - 13.6. Creating a Heat Map 281
    - 13.7. Creating a Three-Dimensional Scatter Plot 283
    - 13.8. Adding a Prediction Surface to a Three-Dimensional Plot 285
    - 13.9. Saving a Three-Dimensional Plot 289
    - 13.10. Animating a Three-Dimensional Plot 291
    - 13.11. Creating a Dendrogram 291
    - 13.12. Creating a Vector Field 294
    - 13.13. Creating a QQ Plot 299
    - 13.14. Creating a Graph of an Empirical Cumulative Distribution Function 301
    - 13.15. Creating a Mosaic Plot 302
    - 13.16. Creating a Pie Chart 307
    - 13.17. Creating a Map 309
    - 13.18. Creating a Choropleth Map 313
    - 13.19. Making a Map with a Clean Background 317
    - 13.20. Creating a Map from a Shapefile 319
14. Output for Presentation
    - 14.1. Outputting to PDF Vector Files 323
    - 14.2. Outputting to SVG Vector Files 325
    - 14.3. Outputting to WMF Vector Files 325
    - 14.4. Editing a Vector Output File 326
    - 14.5. Outputting to Bitmap (PNG/TIFF) Files 327
    - 14.6. Using Fonts in PDF Files 330
    - 14.7. Using Fonts in Windows Bitmap or Screen Output 332
15. Getting Your Data into Shape
    - 15.1. Creating a Data Frame 336
    - 15.2. Getting Information About a Data Structure 337
    - 15.3. Adding a Column to a Data Frame 338
    - 15.4. Deleting a Column from a Data Frame 338
    - 15.5. Renaming Columns in a Data Frame 339
    - 15.6. Reordering Columns in a Data Frame 340
    - 15.7. Getting a Subset of a Data Frame 341
    - 15.8. Changing the Order of Factor Levels 343
    - 15.9. Changing the Order of Factor Levels Based on Data Values 344
    - 15.10. Changing the Names of Factor Levels 345
    - 15.11. Removing Unused Levels from a Factor 347
    - 15.12. Changing the Names of Items in a Character Vector 348
    - 15.13. Recoding a Categorical Variable to Another Categorical Variable 349
    - 15.14. Recoding a Continuous Variable to a Categorical Variable 351
    - 15.15. Transforming Variables 352
    - 15.16. Transforming Variables by Group 354
    - 15.17. Summarizing Data by Groups 357
    - 15.18. Summarizing Data with Standard Errors and Confidence Intervals 361
    - 15.19. Converting Data from Wide to Long 365
    - 15.20. Converting Data from Long to Wide 368
    - 15.21. Converting a Time Series Object to Times and Values 369
* A. Introduction to ggplot2
* Index

-----

## Requalied Packages

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(gcookbook)
library(plyr)
library(dplyr)
library(MASS)
```

----

## 1. R Basics

```{r, eval=FALSE}
## Read data
read.table()
read.csv()
library(xlsx)
read.xlsx()
library(gdata)
read.xls()
library(foreign)
read.spss()   # SPSS data
read.octave() # Matlab data
read.xport()  # SAS data
```

```{r}
ls("package:ggplot2")
```

----

## 2. Quickly Exploring Data

### 2.1 Scatter Plot

```{r}
plot(mtcars$wt, mtcars$mpg)
qplot(mtcars$wt, mtcars$mpg)
qplot(wt, mpg, data = mtcars)
ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_point()
```

### 2.2 Line Graph

```{r}
plot(pressure$temperature, pressure$pressure)
plot(pressure$temperature, pressure$pressure, type = "l")
```


```{r}
plot(pressure$temperature, pressure$pressure, type = "l")
points(pressure$temperature, pressure$pressure)
```

```{r}
plot(pressure$temperature, pressure$pressure, type = "l")
points(pressure$temperature, pressure$pressure)
lines(pressure$temperature, pressure$pressure/2, col = "red")
points(pressure$temperature, pressure$pressure/2, col = "red")
```


```{r}
qplot(temperature, pressure, data = pressure, geom = "line")
qplot(temperature, pressure, data = pressure, geom = c("line", "point"))
ggplot(data = pressure, aes(x = temperature, y = pressure)) + 
    geom_line()
ggplot(data = pressure, aes(x = temperature, y = pressure)) + 
    geom_line() + 
    geom_point()
```

### 2.3 Bar Graph

```{r}
BOD
barplot(BOD$demand)
barplot(BOD$demand, names.arg = BOD$Time)
```

```{r}
barplot(mtcars$cyl)
table(mtcars$cyl)
barplot(table(mtcars$cyl))
```

```{r}
ggplot(data = BOD, aes(x = Time, y = demand)) + 
    geom_bar(stat = "identity")
# Convert the x variable to a factor, so that it is treated as discrete
ggplot(data = BOD, aes(x = factor(Time), y = demand)) + 
    geom_bar(stat = "identity")
```

```{r}
qplot(cyl, data = mtcars)
ggplot(mtcars, aes(x = cyl)) + geom_bar()
qplot(factor(cyl), data = mtcars)
ggplot(mtcars, aes(x = factor(cyl))) + geom_bar()
```

### 2.4 Histogram

#### view the distribution of one-dimensional data

```{r}
hist(mtcars$mpg)
hist(mtcars$mpg, breaks = 10)
```

```{r}
qplot(mpg, data = mtcars)
qplot(mpg, data = mtcars, binwidth = 4)
ggplot(data = mtcars, aes(mpg)) + 
    geom_histogram(binwidth = 4)
```

### 2.5 Box Plot

#### comparing distributions

```{r}
head(ToothGrowth)
plot(ToothGrowth$supp, ToothGrowth$len)
```

```{r}
boxplot(len ~ supp, data = ToothGrowth)
```

```{r}
boxplot(len ~ supp + dose, data = ToothGrowth)
```

```{r}
qplot(x = supp, y = len, data = ToothGrowth, geom = "boxplot")
ggplot(data = ToothGrowth, aes(x = supp, y = len)) +
    geom_boxplot()

qplot(x = interaction(supp, dose), y = len, 
      data = ToothGrowth, 
      geom = "boxplot")
ggplot(data = ToothGrowth, aes(x = interaction(supp, dose), y = len)) + 
    geom_boxplot()
```

### 2.6 Function Curve

```{r}
curve(x^3 + 5*x, from = -4, to = 4)
```

```{r}
myfun <- function(xvar) {
    1/(1 + exp(-xvar + 10))
}
curve(myfun(x), from = 0, to = 20)
```


```{r}
curve(myfun(x), from = 0, to = 20)
curve(1-myfun(x), add = TRUE, col = "red")
```

```{r}
ggplot(data = data.frame(x = c(0, 20)), aes(x = x)) + 
    stat_function(fun = myfun, geom = "line")
```

----

## 3. Bar Graphs

----

## 5. Scatter Plots

> ### display the relationship between two continuous variables

### 5.1 Basic Scatter Plot

```{r}
head(heightweight)
head(heightweight[, c("ageYear", "heightIn")])
```

```{r}
ggplot(data = heightweight, aes(x = ageYear, y = heightIn)) + 
    geom_point()
ggplot(data = heightweight, aes(x = ageYear, y = heightIn)) +
    geom_point(shape = 16)
ggplot(data = heightweight, aes(x = ageYear, y = heightIn)) +
    geom_point(shape = 19)
ggplot(data = heightweight, aes(x = ageYear, y = heightIn)) +
    geom_point(shape = 21)
ggplot(data = heightweight, aes(x = ageYear, y = heightIn)) +
    geom_point(size = 2)
```

### 5.2 Grouping Data Points by a Variable Using Shape or Color

```{r}
head(heightweight[, c("sex", "ageYear", "heightIn")])
ggplot(data = heightweight, aes(x = ageYear, y = heightIn, colour = sex)) +
    geom_point()
ggplot(data = heightweight, aes(x = ageYear, y = heightIn, shape = sex)) + 
    geom_point()
```

```{r}
ggplot(data = heightweight, aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) + 
    geom_point()

ggplot(data = heightweight, aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
    geom_point() + 
    scale_shape_manual(values = c(1, 2)) + 
    scale_colour_brewer(palette = "Set1")
##  scale_colour_manual()
```


### 5.3 Using Different Point Shapes

#### Point Shapes

![alt text](shape.png)

```{r}
ggplot(data = heightweight, aes(x = ageYear, y = heightIn)) + 
    geom_point(shape = 3)
ggplot(heightweight, aes(x = ageYear, y = heightIn, shape = sex)) +
    geom_point(size = 3) + 
    scale_shape_manual(values = c("*", "0"))

# Make a copy of the data
hw <- heightweight
# Categorize into <100 and >=100 groups
hw$weightGroup <- cut(hw$weightLb,
                      breaks = c(-Inf, 100, Inf), 
                      labels = c("< 100", ">= 100"))
# Use shapes with fill and color, and use colors that are empty (NA) and filled
ggplot(hw, aes(x = ageYear, y = heightIn, shape = sex, fill = weightGroup)) + 
    geom_point(size = 2.5) + 
    scale_shape_manual(values = c(21, 24)) + 
    scale_fill_manual(values = c(NA, "black"), 
                      guide = guide_legend(override.aes = list(shape = 21)))
```



### 5.4 Mapping a Continuous Variable to Color or Size

```{r}
ggplot(data = heightweight, aes(x = ageYear, y = heightIn, colour = weightLb)) + 
    geom_point()
ggplot(data = heightweight, aes(x = ageYear, y = heightIn, size = weightLb)) + 
    geom_point()
ggplot(data = heightweight, aes(x = ageYear, y = heightIn, size = weightLb)) + 
    geom_point() +
    scale_size_continuous(range=c(2, 5))
ggplot(heightweight, aes(x = weightLb, y = heightIn, fill = ageYear)) + 
    geom_point(shape = 21, size = 2.5) +
    scale_fill_gradient(low = "black", high = "white")
# Using guide_legend() will result in a discrete legend instead of a colorbar
ggplot(heightweight, aes(x = weightLb, y = heightIn, fill = ageYear)) + 
    geom_point(shape = 21, size = 2.5) + 
    scale_fill_gradient(low = "black", high = "white", breaks = 12:17, guide = guide_legend())
```

```{r}
ggplot(heightweight, aes(x=ageYear, y=heightIn, size=weightLb, colour=sex)) +
geom_point(alpha=.5) +
scale_size_area() + # Make area proportional to numeric value
scale_colour_brewer(palette="Set1")
```


### 5.5 Dealing with Overplotting

```{r}

```

----

## 11. Facets

> ### Rendering groups of data alongside each other, making it easy to compare the groups
> ### Create a subplot for each group and draw the subplots side by side

`Main Function:`

* facet_grid()
* facet_wrap()

### 11.1 Splitting Data into Subplots with Facets

```{r}
head(mpg)
```

```{r}
# The base plot
p = ggplot(mpg, aes(x = displ, y = hwy)) + 
    geom_point()
p
# Faceted by drv, in vertically arranged subpanels
p + facet_grid(drv ~ .)
# Faceted by cyl, in horizontally arranged subpanels
p + facet_grid(. ~ cyl)
# Split by drv (vertical) and cyl (horizontal)
p + facet_grid(drv ~ cyl)
```

----

```{r}
# Facet on class
# Note there is nothing before the tilde
p + facet_wrap( ~ class)
```


```{r}
# These will have the same result: 2 rows and 4 cols
p + facet_wrap( ~ class, nrow=2)
p + facet_wrap( ~ class, ncol=4)
```


### 11.2 Using Facets with Different Axes

```{r}
# The base plot
p = ggplot(mpg, aes(x = displ, y = hwy)) +
    geom_point()
p
# With free x scales
p + facet_grid(drv ~ cyl, scales = "free_x")
# With free y scales
p + facet_grid(drv ~ cyl, scales = "free_y")
# With free x and y scales
p + facet_grid(drv ~ cyl, scales = "free")
```


### 11.3 Changing the Text of Facet Labels

```{r}
mpg2 <- mpg # Make a copy of the original data
# Rename 4 to 4wd, f to Front, r to Rear
levels(mpg2$drv)[levels(mpg2$drv)=="4"] <- "4wd"
levels(mpg2$drv)[levels(mpg2$drv)=="f"] <- "Front"
levels(mpg2$drv)[levels(mpg2$drv)=="r"] <- "Rear"
# Plot the new data
ggplot(mpg2, aes(x = displ, y = hwy)) + 
    geom_point() + 
    facet_grid(drv ~ .)
```

```{r}
ggplot(mpg2, aes(x = displ, y = hwy)) + 
    geom_point() +
    facet_grid(drv ~ ., labeller = label_both)
mpg3 <- mpg
levels(mpg3$drv)[levels(mpg3$drv)=="4"] <- "4^{wd}"
levels(mpg3$drv)[levels(mpg3$drv)=="f"] <- "- Front %.% e^{pi * i}"
levels(mpg3$drv)[levels(mpg3$drv)=="r"] <- "4^{wd} - Front"
ggplot(mpg3, aes(x = displ, y = hwy)) + 
    geom_point() + 
    facet_grid(drv ~ ., labeller = label_parsed)
```



### 11.4 Changing the Appearance of Facet Labels and Headers

```{r}
head(cabbage_exp)
```

```{r}
ggplot(cabbage_exp, aes(x = Cultivar, y = Weight)) + 
    geom_bar(stat = "identity") +
    facet_grid(. ~ Date)
```

```{r}
ggplot(cabbage_exp, aes(x = Cultivar, y = Weight)) + 
    geom_bar(stat = "identity") +
    facet_grid(. ~ Date) +
    theme(strip.text = element_text(face = "bold", size = rel(1.5)),
          strip.background = element_rect(fill = "lightblue", colour = "black", size = 1))
```

----

## 12. Using Colors in Plots

### 12.1 Setting the Colors of Objects

> `colour` controls the color of lines and of the outlines of polygons

> `fill` controls the color of the fill area of polygons

> `point shapes` are sometimes a little different. For most point shapes, the color of the entire point is controlled by colour, not fill. The exception is the point shapes (21–25) that have both a fill and an outline.

```{r}
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(colour = "red")
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(colour = "red", shape = 3)
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(fill = "red", colour = "black", shape = 21)
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(fill = "red", colour = "black", shape = 22)
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(fill = "red", colour = "black", shape = 23)
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(fill = "red", colour = "black", shape = 24)
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) + 
    geom_point(fill = "red", colour = "black", shape = 25)
ggplot(data = birthwt, mapping = aes(x = bwt)) + 
    geom_histogram(fill = "red", colour = "black")
```

## 12.2 Mapping Variables to Colors

> Use a variable (column from a data frame) to control the color of geoms

> In the call to the geom, set the value of colour or fill to the name of one of the columns in the data

```{r}
head(cabbage_exp)
```

# ???

```{r, eval=FALSE}
# These both have the same effect
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) + 
    geom_bar(colour = "black", position = "dodge")
ggplot(cabbage_exp, aes(x = Date, y = Weight)) + 
    geom_bar(aes(fill = Cultivar), colour = "black", position = "dodge")
```


```{r}
# These both have the same effect
ggplot(mtcars, aes(x = wt, y = mpg, colour = cyl)) + 
    geom_point()
ggplot(mtcars, aes(x = wt, y = mpg)) + 
    geom_point(aes(colour = cyl))
```

```{r}
# Convert to factor in call to ggplot()
ggplot(mtcars, aes(x = wt, y = mpg, colour = factor(cyl))) + 
    geom_point()
# Another method: Convert to factor in the data
m = mtcars
m$cyl = factor(m$cyl)
ggplot(m, aes(x = wt, y = mpg, colour = cyl)) + 
    geom_point()
```


## 12.3 Using a Different Palette for a Discrete Variable

### 1. Discrete fill and color scales

Fill scale            | Color scale              | Description
--------------------- | ------------------------ | ---------------------------------------------------
scale_fill_discrete() | scale_colour_discrete()  | Colors evenly spaced around the color wheel (same as hue)
scale_fill_hue()      | scale_colour_hue()       | Colors evenly spaced around the color wheel (same as discrete)
scale_fill_grey()     | scale_colour_grey()      | Greyscale palette
scale_fill_brewer()   | scale_colour_brewer()    | ColorBrewer palettes
scale_fill_manual()   | scale_colour_manual()    | Manually specified colors

> hue() : HCL (hue-chroma-lightness) color space, the default lightness value is 65 on a scale from 0–100.This is good for filled areas, but it’s a bit light for points and lines. 

### 2. Default palette

#### Data

```{r}
head(uspopage)
```

#### Base plot

```{R}
p = ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) + 
    geom_area()
```

#### These three have the same effect

```{r}
p
p + scale_fill_discrete()
p + scale_fill_hue()
```

#### For points and lines. To make the colors darker for points and lines, set the value of l=45 (luminance/lightness):

```{r}
# Basic scatter plot
h = ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) + 
    geom_point()
# Default lightness = 65
h
# Slightly darker
h + scale_colour_hue(l = 45)
```

### 3. ColorBrewer palette (For more about ColorBrewer, see [here](http://colorbrewer.org))

#### All the ColorBrewer palettes

```{r, eval=FALSE}
library(RColorBrewer)
display.brewer.all()
```

![alt text](ColorBrewer.png)

```{r}
p + scale_fill_brewer()
```

```{r}
p + scale_fill_brewer(palette="Oranges")
```

```{r}
p + scale_fill_brewer(palette="BuPu")
```

### 4. Palette of greys. This is useful for print when the output is in black and white. The default is to start at 0.2 and end at 0.8, on a scale from 0 (black) to 1 (white), but you can change the range :

```{r}
p + scale_fill_grey()
# Reverse the direction and use a different range of greys
p + scale_fill_grey(start = 0.7, end = 0)
```

```{r, eval=FALSE}
p + scale_fill_manual()
```

## 12.4 Using a Manually Defined Palette for a Discrete Variable



---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

## 13. Miscellaneous Graphs

### 13.1 相关系数矩阵可视化

> 相关R包:
> 
> 1. corrplot
> 2. corrgram

#### 13.1.1 相关系数矩阵

> * `var` compute the variance of x 
> * `cov` and `cor` compute the covariance or correlation of x and y if these are vectors. If x and y are matrices then the covariances (or correlations) between the columns of x and the columns of y are computed.
> * `cov2cor` scales a covariance matrix into the corresponding correlation matrix efficiently.


```{r, eval= FALSE}
方差：
var(x, y = NULL, na.rm = FALSE, use)
协方差：
cov(x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman"))
相关系数：
cor(x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman"))
将协方差矩阵转化为相关系数矩阵：
cov2cor(V)
```

* `x`:a numeric vector, matrix or data frame.
* `y`:NULL (default) or a vector, matrix or data frame with compatible dimensions to x. The default is equivalent to y = x (but more efficient).
* `na.rm`:logical. Should missing values be removed?
* `use`:an optional character string giving a method for computing covariances in the presence of missing values. This must be (an abbreviation of) one of the strings `"everything"`, `"all.obs"`, `"complete.obs"`, `"na.or.complete"`, or `"pairwise.complete.obs"`.
* `method`:a character string indicating which correlation coefficient (or covariance) is to be computed. One of `"pearson"` (default), `"kendall"`, or `"spearman"`: can be abbreviated.
* `V`:symmetric numeric matrix, usually positive definite such as a covariance matrix

#### **13.1.1 corrplot**

> A graphical display of a correlation matrix, confidence interval. The details are paid great attention to. It can also visualize a general matrix by setting is.corr = FALSE.

```{r, eval=FALSE}
corrplot(corr,
         method = c("circle", "square", "ellipse", "number", "shade", "color", "pie"),
         type = c("full", "lower", "upper"), 
         add = FALSE,
         col = NULL, bg = "white", title = "",  is.corr = TRUE,		
         diag = TRUE, outline = FALSE, mar = c(0,0,0,0),
         addgrid.col = NULL, 
         addCoef.col = NULL, 
         addCoefasPercent = FALSE, 
         order = c("original", "AOE", "FPC", "hclust", "alphabet"),
         hclust.method = c("complete", "ward", "single", "average", "mcquitty", "median", "centroid"),
         addrect = NULL, 
         rect.col = "black", 
         rect.lwd = 2, 
         tl.pos = NULL, 
         tl.cex = 1,
         tl.col = "red", 
         tl.offset = 0.4, 
         tl.srt = 90,
         cl.pos = NULL, 
         cl.lim = NULL,
         cl.length = NULL, 
         cl.cex = 0.8, 
         cl.ratio = 0.15, 
         cl.align.text = "c",
         cl.offset = 0.5,
         addshade = c("negative", "positive", "all"),
         shade.lwd = 1, 
         shade.col = "white",
         p.mat = NULL, 
         sig.level = 0.05,
         insig = c("pch","p-value","blank", "n"),
         pch = 4, 
         pch.col = "black", 
         pch.cex = 3,
         plotCI = c("n","square", "circle", "rect"),
         lowCI.mat = NULL, 
         uppCI.mat = NULL, ...)
```




#### 数据：

```{r}
head(mtcars)
```

#### 计算相关系数矩阵：

> * If there are any columns that you don’t want used for correlations (for example, a column of names), you should exclude them. 
> * If there are any NA cells in the original data, the resulting correlation matrix will have NA values. To deal with this, you will probably want to use the option `use = "complete.obs"` or `use = "pairwise.complete.obs"`.

```{r}
mcor <- cor(mtcars)
round(mcor, digits=2)
```

#### 图一：

```{r}
library(corrplot)
corrplot(mcor)
```

#### 图二：

```{r}
corrplot(mcor, method = "shade", shade.col = NA, tl.col = "black", tl.srt = 45)
```

#### 图三：

```{r, warning=FALSE}
# Generate a lighter palette
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
corrplot(mcor, 
         method = "shade", 
         shade.col = NA, 
         tl.col = "black", 
         tl.srt = 45, 
         col = col(200), 
         addCoef.col = "black", 
         addcolorlabel = "no", 
         order = "AOE")
```

```{r, eval=FALSE}
?corrplot()
```


```{r}
data(mtcars)
M <- cor(mtcars)
##  different color series
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white", 
			"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
			"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))	
col3 <- colorRampPalette(c("red", "white", "blue"))	
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F", 
			"cyan", "#007FFF", "blue","#00007F"))	
wb <- c("white","black")


par(ask = TRUE)


## different color scale and methods to display corr-matrix
corrplot(M, method="number", col="black", cl.pos="n")
corrplot(M, method="number")
corrplot(M)
corrplot(M, order ="AOE")
corrplot(M, order ="AOE", addCoef.col="grey")

corrplot(M, order="AOE", col=col1(20), cl.length=21,addCoef.col="grey")
corrplot(M, order="AOE", col=col1(10),addCoef.col="grey")

corrplot(M, order="AOE", col=col2(200))
corrplot(M, order="AOE", col=col2(200),addCoef.col="grey")
corrplot(M, order="AOE", col=col2(20), cl.length=21,addCoef.col="grey")
corrplot(M, order="AOE", col=col2(10),addCoef.col="grey")

corrplot(M, order="AOE", col=col3(100))
corrplot(M, order="AOE", col=col3(10))


corrplot(M, method="color", col=col1(20), cl.length=21,order = "AOE", addCoef.col="grey")
corrplot(M, method="square", col=col2(200),order = "AOE")
corrplot(M, method="ellipse", col=col1(200),order = "AOE")
corrplot(M, method="shade", col=col3(20),order = "AOE")
corrplot(M, method="pie", order = "AOE")

## col=wb
corrplot(M, col = wb, order="AOE", outline=TRUE, cl.pos="n")
## like Chinese wiqi, suit for either on screen or white-black print.
corrplot(M, col = wb, bg="gold2",  order="AOE", cl.pos="n")


## mixed methods: It's more efficient if using function "corrplot.mixed"
## circle + ellipse
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="ell",order="AOE",
	diag=FALSE,tl.pos="n", cl.pos="n")
	
## circle + square
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="square",order="AOE",
	diag=FALSE,tl.pos="n", cl.pos="n")

## circle + colorful number
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="number",order="AOE",
	diag=FALSE,tl.pos="n", cl.pos="n")

## circle + black number
corrplot(M,order="AOE",type="upper",tl.pos="tp")
corrplot(M,add=TRUE, type="lower", method="number",order="AOE", col="black",
	diag=FALSE,tl.pos="n", cl.pos="n")

	
## order is hclust and draw rectangles
corrplot(M, order="hclust")
corrplot(M, order="hclust", addrect = 2)
corrplot(M, order="hclust", addrect = 3, rect.col = "red")
corrplot(M, order="hclust", addrect = 4, rect.col = "blue")
corrplot(M, order="hclust", hclust.method="ward", addrect = 4)



## visualize a  matrix in [0, 1]
corrplot(abs(M),order="AOE", cl.lim=c(0,1))
corrplot(abs(M),order="AOE", col=col1(20), cl.lim=c(0,1))
corrplot(abs(M),order="AOE", col=col3(200), cl.lim=c(0,1))


## visualize a  matrix in [-100, 100]
ran <- round(matrix(runif(225, -100,100), 15))
corrplot(ran, is.corr=FALSE)
corrplot(ran, is.corr=FALSE, cl.lim=c(-100, 100))


## text-labels and plot type
corrplot(M, order="AOE", tl.srt=45)
corrplot(M, order="AOE", tl.srt=60)
corrplot(M, order="AOE", tl.pos="d",cl.pos="n")
corrplot(M, order="AOE", diag=FALSE, tl.pos="d")
corrplot(M, order="AOE", type="upper")
corrplot(M, order="AOE", type="upper", diag=FALSE)
corrplot(M, order="AOE", type="lower", cl.pos="b")
corrplot(M, order="AOE", type="lower", cl.pos="b", diag=FALSE)



#### color-legend
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="l")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="c")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="r")
corrplot(M, order="AOE", cl.pos="b")
corrplot(M, order="AOE", cl.pos="b", tl.pos="d")
corrplot(M, order="AOE", cl.pos="n")



##the input matrix is not square
corrplot(M[1:8,])
corrplot(M[,1:8])



cor.mtest <- function(mat, conf.level = 0.95){
	mat <- as.matrix(mat)
	n <- ncol(mat)
	p.mat <- lowCI.mat <- uppCI.mat <- matrix(NA, n, n)
	diag(p.mat) <- 0
	diag(lowCI.mat) <- diag(uppCI.mat) <- 1
	for(i in 1:(n-1)){
		for(j in (i+1):n){
			tmp <- cor.test(mat[,i], mat[,j], conf.level = conf.level)
			p.mat[i,j] <- p.mat[j,i] <- tmp$p.value
			lowCI.mat[i,j] <- lowCI.mat[j,i] <- tmp$conf.int[1]
			uppCI.mat[i,j] <- uppCI.mat[j,i] <- tmp$conf.int[2]
		}
	}
	return(list(p.mat, lowCI.mat, uppCI.mat))
}

res1 <- cor.mtest(mtcars,0.95)
res2 <- cor.mtest(mtcars,0.99)


## specialized the insignificant value according to the significant level
corrplot(M, p.mat = res1[[1]], sig.level=0.2)
corrplot(M, p.mat = res1[[1]], sig.level=0.05)
corrplot(M, p.mat = res1[[1]], sig.level=0.01)
corrplot(M, p.mat = res1[[1]], insig = "blank")
corrplot(M, p.mat = res1[[1]], insig = "p-value")
corrplot(M, p.mat = res1[[1]], insig = "p-value", sig.level=-1) ## add all p-values
corrplot(M, p.mat = res1[[1]], order="hclust", insig = "blank", addrect=3)
corrplot(M, p.mat = res1[[1]], order="hclust", insig = "pch", addrect=3)



## plot confidence interval(0.95), "square" method	
corrplot(M,low=res1[[2]], upp=res1[[3]],
	plotC="circle", addg="grey20",cl.pos="n")
corrplot(M, p.mat = res1[[1]],low=res1[[2]], upp=res1[[3]],
	plotC="circle", addg="grey20",cl.pos="n")
corrplot(M, low=res1[[2]], upp=res1[[3]], 
	col=c("white","black"),bg="gold2",order="AOE",
	plotCI="circle",cl.pos="n",pch.col="red")
corrplot(M, p.mat = res1[[1]], low=res1[[2]], upp=res1[[3]], 
	col=c("white","black"),bg="gold2",order="AOE",
	plotCI="circle",cl.pos="n",pch.col="red")
	
## plot confidence interval(0.95), "square" method	
corrplot(M, low=res1[[2]], upp=res1[[3]],
	col=c("white","black"),bg="gold2", order="AOE",
	plotCI="square",addg=NULL,cl.pos="n")
corrplot(M, p.mat = res1[[1]],low=res1[[2]], upp=res1[[3]],
	col=c("white","black"),bg="gold2",order="AOE",pch.col="red", 
	plotC="square", addg=NULL,cl.pos="n")
	
## plot confidence interval(0.95, 0.95, 0.99), "rect" method
corrplot(M, low=res1[[2]], upp=res1[[3]], order="hclust",
	rect.col="navy", plotC="rect",cl.pos="n")
corrplot(M, p.mat = res1[[1]], low=res1[[2]], upp=res1[[3]], order="hclust",
	pch.col="red", sig.level = 0.05, addrect=3, rect.col="navy",
	plotC="rect",cl.pos="n")
corrplot(M, p.mat = res2[[1]], low=res2[[2]], upp=res2[[3]], order="hclust",
	pch.col="red", sig.level = 0.01, addrect=3, rect.col="navy",
	plotC="rect",cl.pos="n")


## an animation of changing confidence interval in different significance level
## begin.animaton
par(ask=FALSE)
for(i in seq(0.1, 0, -0.005)){
	tmp <- cor.mtest(mtcars,1-i)
	corrplot(M, p.mat = tmp[[1]], low=tmp[[2]], upp=tmp[[3]], order="hclust",
		pch.col="red", sig.level = i, plotC="rect", cl.pos="n",
		mar=c(0,0,1,0), 
		title=substitute(alpha == x,list(x=format(i,digits=3,nsmall=3))))
	Sys.sleep(0.15)
}
## end.animaton


```



#### 13.1.2 `corrgram`

* The `corrgram` package is an implementation of correlograms. This vignette reproduces most of the figures in Friendly (2002).
* Description
    - The corrgram function produces a graphical display of a correlation matrix, called a correlogram. The cells of the matrix can be shaded or colored to show the correlation value.
* Usage

```{r, eval=FALSE}
corrgram(x, 
         # type = NULL, 
         order = FALSE/TRUE/"PCA"/"OLO"/"GW"/"HC", 
         labels, 
         panel = panel.shade,
         # panel.pts, panel.pie, panel.shade, panel.bar, panel.ellipse, panel.conf. panel.cor
         lower.panel = panel, upper.panel = panel, 
         # panel.txt, panel.minmax, panel.density
         diag.panel = NULL, text.panel = textPanel,
         label.pos = c(0.5, 0.5), label.srt = 0, 
         cex.labels = NULL, 
         font.labels = 1, 
         row1attop = TRUE, 
         dir = "",
         gap = 0, 
         abs = FALSE, 
         col.regions = colorRampPalette(c("red", "salmon", "white", "royalblue",  "navy")), 
         cor.method = "pearson", ...)
```

* Arguments
    - `x`:A tall data frame with one observation per row, or a correlation matrix.
    - `type`:Use 'data' or 'cor'/'corr' to explicitly specify that 'x' is data or a correlation matrix. Rarely needed.
    - `order`:Should variables be re-ordered? Use `TRUE/"PCA"` for PCA-based re-ordering. Options from the `'seriate'` package include `"OLO"` for optimal leaf ordering, `"GW"`, and `"HC"`.
    - `labels`:Labels to use (instead of data frame variable names) for diagonal panels
    - `panel`:Function used to plot the contents of each panel
    - `lower.panel`, `upper.panel`:Separate panel functions used below/above the diagonal
    - `diag.panel`, `text.panel`:Panel function used on the diagonal
    - `label.pos`:Horizontal and vertical placement of label in diagonal panels
    - `label.srt`:String rotation for diagonal labels
    - `cex.labels`, `font.labels`:Graphics parameter for diagonal panels
    - `row1attop`:TRUE for diagonal like " \ ", FALSE for diagonal like " / ".
    - `dir`:Use dir="left" instead of 'row1attop'
    - `gap`:Distance between panels
    - `abs`:Use absolute value of correlations for clustering? Default FALSE
    - `col.regions`:A function returning a vector of colors
    - `cor.method`:Correlation method to use in panel functions. Default is 'pearson'. Alternatives: 'spearman', 'kendall'
    - `...`:Additional arguments passed to plotting methods.



#### 数据：

The data are 11 measures of performance and salary for 263 baseball players in the 1986 baseball season in the United States. The data were used in 1988 Data Expo at the Joint Statistical Meetings.


```{r}
library(corrgram)
head(baseball)
```

#### 计算相关系数矩阵：

```{r}
round(cor(baseball[, 5:14], use = "pair"), 2)
```

#### 图一：

```{r}
vars2 <- c("Assists", "Atbat", "Errors", "Hits", "Homer", "logSal",
           "Putouts", "RBI", "Runs", "Walks", "Years")
corrgram(baseball[,vars2], order = TRUE,
         main = "Baseball data PC2/PC1 order",
         lower.panel = panel.shade, upper.panel = panel.pie,
         diag.panel = panel.minmax, text.panel = panel.txt)
```


#### 图一：

```{r}
baseball.cor <- cor(baseball[, vars2], use = 'pair')
baseball.eig <- eigen(baseball.cor)$vectors[, 1:2]
e1 <- baseball.eig[, 1]
e2 <- baseball.eig[, 2]
plot(e1, e2, col = 'white', xlim = range(e1, e2), ylim = range(e1, e2))
text(e1, e2, rownames(baseball.cor), cex = 1)
title("Eigenvector plot of baseball data")
arrows(0, 0, e1, e2, cex = 0.5, col = "red", length = 0.1)
```


#### 图一：

```{r}
corrgram(baseball[, vars2], main = "Baseball data (alphabetic order)")
```

The variables are sorted according to a `principal component ordering` to look for possible clustering of the variables. It is not surprising to see that more times at bat is strongly correlated with a higher number of hits and a higher number of runs.

```{r}
corrgram(baseball[, vars2], order = TRUE, main = "Baseball data (PC order)",
         panel = panel.shade, text.panel = panel.txt)
```


#### 图一：

```{r}
corrgram(baseball, order=TRUE, main="Baseball data (PC order)")
```

#### 图一：

```{r}
corrgram(baseball[,vars2], order=TRUE,
         main="Baseball correlation ellipses",
         panel=panel.ellipse,
         text.panel=panel.txt, diag.panel=panel.minmax)
```

```{r}
corrgram(iris,
         main = "Iris data with example panel functions",
         lower.panel =panel.pts, upper.panel = panel.conf,
         diag.panel = panel.density)
```


```{r}
corrgram(auto, order = TRUE,
         main = "Auto data (PC order)",
         lower.panel = corrgram::panel.ellipse,
         upper.panel = panel.bar, diag.panel = panel.minmax,
         col.regions = colorRampPalette(c("darkgoldenrod4", "burlywood1", "darkkhaki", "darkgreen")))
```

```{r}
# 'vote' is a correlation matrix, not a data frame
corrgram(vote, order = TRUE,
         upper.panel = panel.cor, main = "vote")
```


---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

### 13.2 Plotting a Function

```{r}
# The data frame is only used for setting the range
p = ggplot(data.frame(x = c(-3,3)), aes(x = x))
p + stat_function(fun = dnorm)
p + stat_function(fun = dt, args = list(df = 2))
```

```{r}
myfun = function(xvar) {
    1/(1 + exp(-xvar + 10))
}
ggplot(data.frame(x = c(0, 20)), aes(x = x)) + 
    stat_function(fun = myfun)
```


#### To smooth out the curve, pass a larger value of n to `stat_function()`

```{r}
ggplot(data.frame(x = c(0, 20)), aes(x = x)) + 
    stat_function(fun = myfun, n = 200)
```

### 13.3 Shading a Subregion Under a Function Curve

```{r}
# Return dnorm(x) for 0 < x < 2, and NA for all other x
dnorm_limit <- function(x) {
    y <- dnorm(x) 
    y[x < 0 | x > 2] <- NA
    return(y)
}
# ggplot() with dummy data
p = ggplot(data.frame(x = c(-3, 3)), aes(x = x))
p + 
    stat_function(fun = dnorm_limit, geom = "area", fill = "blue", alpha = 0.2) + 
    stat_function(fun = dnorm)
```

### 13.4 Creating a Network Graph

```{r, message=FALSE}
library(igraph)
```

```{r}
# Specify edges for a directed graph
gd = graph(c(1,2, 2,3, 2,4, 1,4, 5,5, 3,6))
gd
plot(gd)
```

```{r}
# For an undirected graph, No labels
gu = graph(c(1,2, 2,3, 2,4, 1,4, 5,5, 3,6), directed = FALSE)
gu
plot(gu, vertex.label = NA)
```


```{r}
str(gd)
str(gu)
```

### 13.7 Creating a Three-Dimensional Scatter Plot

```{r,eval=FALSE}
library(rgl)
```


----

## 15. Getting Your Data into Shape

### 15.1 Creating a Data Frame

>A data frame is essentially a list of vectors and factors. Each vector or factor can be thought of as a column in the data frame.

```{r}
# Two starting vectors
g = c("A", "B", "C")
x = 1:3
dat = data.frame(g, x)
dat
```

```{r}
lst = list(group = g, value = x) # A list of vectors
lst
dat = as.data.frame(lst)
dat
```

### 15.2 Getting Information About a Data Structure

```{r}
str(ToothGrowth)
```

```{r}
tg <- ToothGrowth
tg$supp <- as.character(tg$supp)
str(tg)
ToothGrowth$supp
tg$supp
```

### 15.3 Adding a Column to a Data Frame

```{r, eval=FALSE}
data$newcol <- NA
data$newcol <- vec
```

### 15.4 Deleting a Column from a Data Frame

```{r, eval=FALSE}
data$badcol <- NULL
# Return data without badcol
data <- subset(data, select = -badcol)
# Exclude badcol and othercol
data <- subset(data, select = c(-badcol, -othercol))
```

### 15.5 Renaming Columns in a Data Frame

### 15.6 Reordering Columns in a Data Frame

### 15.7 Getting a Subset of a Data Frame

### 15.8 Changing the Order of Factor Levels

### 15.9 Changing the Order of Factor Levels Based on Data Values

### 15.10 Changing the Names of Factor Levels

### 15.11 Removing Unused Levels from a Factor

### 15.12 Changing the Names of Items in a Character Vector

### 15.13 Recoding a Categorical Variable to Another Categorical Variable

### 15.14 Recoding a Continuous Variable to a Categorical Variable

### 15.15 Transforming Variables

### 15.16 Transforming Variables by Group

### 15.17 Summarizing Data by Groups

### 15.18 Summarizing Data with Standard Errors and Confidence Intervals

### 15.19 Converting Data from Wide to Long

### 15.20 Converting Data from Long to Wide

### 15.21 Converting a Time Series Object to Times and Values

```{r}
nhtemp
```

```{r}
# Get times for each observation
as.numeric(time(nhtemp))
```

```{r}
# Get value of each observation
as.numeric(nhtemp)
```

```{r}
# Put them in a data frame
nht <- data.frame(year = as.numeric(time(nhtemp)), temp = as.numeric(nhtemp))
nht
```

```{r}
presidents
pres_rating = data.frame(year = as.numeric(time(presidents)),
                         rating = as.numeric(presidents))
pres_rating
```

```{r}
pres_rating2 = data.frame(year = as.numeric(floor(time(presidents))),
                          quarter = as.numeric(cycle(presidents)),
                          rating = as.numeric(presidents))
pres_rating2
```

